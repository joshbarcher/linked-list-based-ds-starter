import adts.IQueue;
import org.junit.Before;
import org.junit.Test;

import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.NoSuchElementException;

import static org.junit.Assert.*;

/**
 * Tests an implementation of the IBoundedQueue interface.
 *
 * DO NOT EDIT THIS FILE!
 *
 * @author Josh Archer
 * @version 1.0
 */
public class QueueTest
{
    private IQueue<Integer> queue;

    //test elements
    private int[] testArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    private int[] missing = {11, 12, 13};

    /*
        This method should create and return a new queue
        for the methods below.
     */
    private IQueue createQueue()
    {
        return null;
    }

    /**
     * Creates a new queue before each of the tests below.
     */
    @Before
    public void setup()
    {
        queue = createQueue();
    }

    /**
     * Verifies that the capacity is not available.
     */
    @Test(expected = UnsupportedOperationException.class)
    public void capacityUnavailableTest()
    {
        queue.getCurrentCapacity();
    }

    /**
     * Verifies that the capacity is not available.
     */
    @Test(expected = UnsupportedOperationException.class)
    public void isFullUnavailableTest()
    {
        queue.isFull();
    }

    /**
     * Verifies that
     */
    @Test
    public void fullQueueResizesTest()
    {
        addElementsToFullQueue();

        //one too many for a queue of size 5
        queue.add(11);
        assertEquals(11, queue.size());
    }

    /**
     * Verifies that you cannot remove an element from
     * an empty queue.
     */
    @Test(expected = NoSuchElementException.class)
    public void emptyQueueTest()
    {
        //remove a missing element
        queue.remove();
    }

    /**
     * Verifies that an element can be removed from the queue.
     */
    @Test
    public void removeTest()
    {
        addElementsToFullQueue();

        //remove the element
        int removed = (int)queue.remove();
        assertEquals("Added a single element, but didn't receive the " +
                            "element with remove()", 1, removed);
    }

    /**
     * Verifies that elements are returned in FIFO order.
     */
    @Test
    public void fifoTest()
    {
        addElementsToFullQueue();

        //make sure elements removed are in FIFO order
        for (int i = 0; i < testArray.length; i++)
        {
            assertEquals("Removed element does not match FIFO order",
                                testArray[i], queue.remove().intValue());
        }
    }

    /**
     * Verifies that elements that are in the queue
     * can be found
     */
    @Test
    public void containsExistsTest()
    {
        addElementsToFullQueue();

        //make sure elements are discoverable
        for (int i = 0; i < testArray.length; i++)
        {
            assertTrue("Added element not discoverable by contains()",
                                queue.contains(testArray[i]));
        }
    }

    /**
     * Verifies that missing elements are not found with
     * contains().
     */
    @Test
    public void containsMissingTest()
    {
        addElementsToFullQueue();

        //make sure elements are discoverable
        for (int i = 0; i < missing.length; i++)
        {
            assertFalse("Missing element is discoverable by contains()",
                                queue.contains(missing[i]));
        }
    }

    /**
     * Verifies that missing elements cannot be found
     * with contains() on an empty queue.
     */
    @Test
    public void containsOnEmptyQueueTest()
    {
        //contains should always return false on empty queue
        assertFalse("Missing element is discoverable by contains()",
                            queue.contains(9));

        //add an element and confirm contains() can discover it
        queue.add(9);
        assertTrue("Element added to queue is not discoverable by contains()",
                            queue.contains(9));
    }

    /**
     * Verifies that a missing element results in an exception.
     */
    @Test(expected = UnsupportedOperationException.class)
    public void removeElementTest()
    {
        //this should always result in an exception
        queue.remove(2);
    }

    /**
     * Verifies that the size of the queue is reported correctly
     * for an empty queue.
     */
    @Test
    public void initialStateTest()
    {
        //queue should be empty to start with
        assertEquals("Queue should have size 0 when created", 0, queue.size());
        assertTrue("Queue should be empty when created", queue.isEmpty());
    }

    /**
     * Verifies that a queue with elements can report
     * how many are present correctly.
     */
    @Test
    public void sizeTest()
    {
        addElementsToPartialQueue();

        //queue should be empty to start with
        assertEquals("Queue size not correct after a few calls to add()",
                            testArray.length / 2, queue.size());
        assertFalse("Queue should not be empty after calling add()", queue.isEmpty());
    }

    /**
     * Verifies that isFull() reports correctly for an empty queue.
     */
    @Test
    public void emptyTest()
    {
        assertTrue("Empty queue should be empty", queue.isEmpty());

        addElementsToPartialQueue();
        assertFalse("Non-empty queue not reported as empty", queue.isEmpty());
    }

    /**
     * Verifies that the size is reported correctly after calling
     * clear on an empty queue.
     */
    @Test
    public void clearEmptyTest()
    {
        //make sure no errors are encountered
        queue.clear();

        assertEquals("Queue size should be 0 after calling clear()", 0, queue.size());
        assertTrue("Queue should be empty after calling clear", queue.isEmpty());
    }

    /**
     * Verifies that the size is reported correctly after calling
     * clear on a non-empty queue.
     */
    @Test
    public void clearNotEmptyTest()
    {
        addElementsToPartialQueue();

        //make sure no errors are encountered
        queue.clear();

        assertEquals("Queue size should be 0 after calling clear()", 0, queue.size());
        assertTrue("Queue should be empty after calling clear", queue.isEmpty());
    }

    /**
     * Verifies that the queue behaves as expected when given
     * a large number of elements.
     */
    @Test
    public void largeQueueTest()
    {
        //add a few elements
        for (int i = 1; i <= 1000; i++)
        {
            queue.add(i);
        }

        assertEquals("Queue should have a size of 1000 after 1000 additions", 1000, queue.size());
        assertFalse("Queue should not be empty after 1000 additions", queue.isEmpty());

        //elements should be returned in order
        for (int i = 1; i <= 1000; i++)
        {
            assertEquals("Elements not returned in FIFO order", i, queue.remove().intValue());
        }
    }

    /**
     * Verifies that intermixed calls to add() and remove()
     * behave correctly.
     */
    @Test
    public void regularModificationsTest()
    {
        //repeatedly add/remove elements
        for (int i = 1; i <= 4; i++)
        {
            //add 2
            int[] elemsToAdd = {2, 4};
            for (int j = 0; j < elemsToAdd.length; j++)
            {
                queue.add(elemsToAdd[j]);
            }

            //remove 1
            for (int j = 0; j < elemsToAdd.length - 1; j++)
            {
                queue.remove();
            }
        }

        //There should be four net elements in the end
        assertEquals("The number of elements left in the queue after repeatedly " +
                            "calling add() and remove() is incorrect", 4, queue.size());
        assertFalse("The queue should not be empty after repeatedly calling add() and remove()",
                            queue.isEmpty());
    }

    /**
     * Verifies that add works correctly after removing all
     * elements from the queue.
     */
    @Test
    public void addAfterEmptyingQueueTest()
    {
        addElementsToFullQueue();

        for (int i = 0; i < testArray.length; i++)
        {
            queue.remove();
        }

        //add a single element after emptying the queue
        queue.add(8);
        assertEquals("Queue should have a size of 1 after adding a single " +
                            "element to a 'recently' emptied queue", 1, queue.size());
        assertTrue("Queue should detect a single element after emptying the queue",
                            queue.contains(8));
    }

    private void addElementsToFullQueue()
    {
        for (int i = 0; i < testArray.length; i++)
        {
            queue.add(testArray[i]);
        }
        assertEquals("The size of your queue should be " + testArray.length +
                            " after calling add() " + testArray.length + " times",
                            testArray.length, queue.size());
    }

    private void addElementsToPartialQueue()
    {
        int length = (testArray.length / 2);
        for (int i = 0; i < testArray.length / 2; i++)
        {
            queue.add(testArray[i]);
        }
        assertEquals("The size of your queue should be " + length +
                            " after calling add() " + length + " times",
                            length, queue.size());
    }

    /**
     * Verifies that an iterator is returned for an empty
     * queue.
     */
    @Test
    public void iteratorWithEmptyQueueTest()
    {
        Iterator<Integer> iter = queue.iterator();
        assertFalse("Iterator should not report elements for an empty queue",
                iter.hasNext());
    }

    /**
     * Verifies the iterator returns elements in FIFO order
     * for a full queue.
     */
    @Test
    public void iteratorFullTest()
    {
        addElementsToFullQueue();
        verifyIteratorElements(testArray.length);
    }

    /**
     * Verifies the iterator returns elements in FIFO order
     * for a partially full queue.
     */
    @Test
    public void iteratorPartialTest()
    {
        addElementsToPartialQueue();
        verifyIteratorElements(testArray.length / 2);
    }

    private void verifyIteratorElements(int maxIndex)
    {
        //verify elements returned in FILO order
        Iterator<Integer> iter = queue.iterator();
        for (int i = 0; i < maxIndex; i++)
        {
            assertTrue("hasNext() should return true for existing elements in the queue",
                    iter.hasNext());
            assertEquals("next() should return elements in FIFO order",
                    testArray[i], iter.next().intValue());
        }

        assertFalse("Iterator should not report more elements after all have been returned",
                iter.hasNext());
    }

    /**
     * Verifies that the for-each loop works with the iterator
     */
    @Test
    public void forEachTest()
    {
        addElementsToFullQueue();

        //a for-each loop should run without error
        int count = 0;
        for (int element : queue)
        {
            assertEquals("next() should return elements in FIFO order",
                    testArray[count], element);
            count++;
        }
    }

    /**
     * Verifies that elements cannot be removed from the
     * queue while using the iterator.
     */
    @Test(expected = ConcurrentModificationException.class)
    public void concurrentRemoveTest()
    {
        addElementsToFullQueue();

        for (int element : queue)
        {
            assert element != 0;
            queue.remove(); //alter elements while iterating
        }
    }

    /**
     * Verifies that elements cannot be added to the
     * queue while using the iterator.
     */
    @Test(expected = ConcurrentModificationException.class)
    public void concurrentAddTest()
    {
        addElementsToPartialQueue();

        for (int element : queue)
        {
            queue.add(element); //alter elements while iterating
        }
    }

    /**
     * Verifies that elements cannot be removed (using clear())
     * from the queue while using the iterator.
     */
    @Test(expected = ConcurrentModificationException.class)
    public void concurrentClearTest()
    {
        addElementsToFullQueue();

        for (int element : queue)
        {
            assert element != 0;
            queue.clear(); //alter elements while iterating
        }
    }
}


